<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mohr Circle Visualiser</title>
  <style>
    :root{
      --bg0:#ece8dc;
      --bg1:#f6f3ea;
      --panel:#fbf8ef;
      --panel2:#f2ecdf;
      --stroke:#b9b2a2;
      --stroke2:#d3cbb9;
      --text:#1f2c3c;
      --muted:#526173;
      --muted2:#7b8796;
      --accent:#255f85;
      --accent2:#bf6d2a;
      --warn:#7a4b99;
      --shadow: 0 12px 28px rgba(41,34,23,.14);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: "Avenir Next", "Trebuchet MS", "Segoe UI", sans-serif;
      background:
        linear-gradient(135deg, rgba(255,255,255,.55), rgba(255,255,255,0) 48%),
        radial-gradient(900px 600px at 15% 5%, #faf5e8 0%, var(--bg1) 48%, var(--bg0) 100%);
      color:var(--text);
      overflow-x:hidden;
    }

    
    body:before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(45,69,96,.05) 0 1px, transparent 1px 26px),
        repeating-linear-gradient(90deg, rgba(45,69,96,.04) 0 1px, transparent 1px 26px);
      opacity:.32;
    }

    .wrap{
      max-width: 1200px;
      margin: 26px auto;
      padding: 18px;
    }

    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      margin-bottom: 14px;
    }
    .title{
      display:flex; flex-direction:column; gap:6px;
    }
    h1{
      font-size: 22px;
      letter-spacing: .06em;
      text-transform: uppercase;
      margin:0;
      color:#16263a;
    }
    .sub{
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
      max-width: 70ch;
    }

    .topbar{
      display:flex; gap:10px; align-items:center;
    }
    .pill{
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.45));
      border: 1px solid rgba(26,60,92,.2);
      border-radius: 999px;
      box-shadow: 0 6px 14px rgba(49,43,34,.1);
      backdrop-filter: blur(8px);
    }
    .pill label{
      font-size: 12px;
      color:var(--muted);
      letter-spacing:.06em;
      text-transform: uppercase;
    }
    .pill select{
      background: rgba(255,255,255,.9);
      color: var(--text);
      border: 1px solid rgba(31,44,60,.15);
      border-radius: 999px;
      padding: 7px 10px;
      outline:none;
    }

    .grid{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
      align-items:start;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.78), rgba(255,255,255,.62));
      border: 1px solid rgba(89,106,124,.24);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card:after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(600px 260px at 20% 0%, rgba(37,95,133,.08), transparent 55%),
                  radial-gradient(520px 240px at 80% 0%, rgba(191,109,42,.08), transparent 60%);
      pointer-events:none;
      opacity:.85;
    }

    .panelHead{
      position:relative;
      z-index:1;
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid rgba(70,86,102,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.6), rgba(245,239,227,.55));
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .panelHead .k{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    .panelHead .v{
      font-size: 12px;
      color: #20344a;
      letter-spacing:.02em;
      opacity:.95;
      text-align:right;
      white-space:nowrap;
    }

    .panelBody{
      position:relative;
      z-index:1;
      padding: 14px;
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items:center;
    }
    .row .meta{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .row .meta .name{
      display:flex;
      gap:8px;
      align-items:baseline;
      font-weight:600;
      letter-spacing:.02em;
    }
    .row .meta .name small{
      font-weight:500;
      color:var(--muted2);
      letter-spacing:.06em;
      text-transform: uppercase;
      font-size: 11px;
    }
    .row .meta .hint{
      font-size: 12px;
      color: var(--muted);
    }
    .valueBox{
      min-width: 92px;
      text-align:right;
      font-variant-numeric: tabular-nums;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(85,99,114,.22);
      background: rgba(255,255,255,.7);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.6);
    }

    .slider{
      margin-top:8px;
      position:relative;
      padding: 10px 0 0 0;
    }
    input[type="range"]{
      width:100%;
      -webkit-appearance:none;
      appearance:none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(37,95,133,.72), rgba(191,109,42,.7));
      outline:none;
      opacity:.95;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, #f5d9bf 40%, #bf6d2a 100%);
      border: 1px solid rgba(255,255,255,.85);
      box-shadow: 0 8px 16px rgba(51,36,22,.25);
      cursor: pointer;
      transition: transform .12s ease;
    }
    input[type="range"]::-webkit-slider-thumb:active{ transform: scale(1.08); }
    input[type="range"]::-moz-range-thumb{
      width: 18px; height:18px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, #f5d9bf 40%, #bf6d2a 100%);
      border: 1px solid rgba(255,255,255,.85);
      box-shadow: 0 8px 16px rgba(51,36,22,.25);
      cursor:pointer;
    }

    .twoCols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .btnRow{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 8px;
    }
    button{
      border: 1px solid rgba(31,44,60,.2);
      background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(241,235,223,.85));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      box-shadow: 0 6px 14px rgba(51,36,22,.14);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      letter-spacing:.04em;
      font-size: 12px;
      text-transform: uppercase;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(37,95,133,.45);
    }
    button:active{ transform: translateY(0px) scale(.99); }

    .charts{
      display:grid;
      grid-template-rows: 1fr 1fr;
      gap: 14px;
    }

    .canvasWrap{
      height: 380px;
      position:relative;
    }
    .canvasWrap.small{ height: 330px; }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .legend{
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
      align-items:center;
      font-size: 12px;
      color: var(--muted);
    }
    .swatch{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:10px;
      height:10px;
      border-radius: 999px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.15);
    }
    .dot.a{ background: rgba(37,95,133,.95); }
    .dot.b{ background: rgba(191,109,42,.95); }
    .dot.c{ background: rgba(122,75,153,.95); }

    .foot{
      margin-top: 10px;
      color: var(--muted2);
      font-size: 12px;
      line-height:1.5;
    }

    
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .canvasWrap{ height: 340px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Mohr Circle Visualiser</h1>
        <div class="sub">
          Visualises <b>σx′(θ)</b> and <b>τx′y′(θ)</b> plus the <b>Mohr circle</b> in (σ, τ) space.
          Industrial UI, smooth motion
        </div>
      </div>

      <div class="topbar">
        <div class="pill">
          <label for="units">Units</label>
          <select id="units">
            <option value="MPa">MPa</option>
            <option value="Pa">Pa</option>
            <option value="kPa">kPa</option>
            <option value="psi">psi</option>
          </select>
        </div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="panelHead">
          <div class="k">Parameters</div>
          <div class="v" id="derivedLine">Center C = —, Radius R = —</div>
        </div>
        <div class="panelBody">
          <div class="controls">

            <div class="row">
              <div class="meta">
                <div class="name">σx <small>normal stress</small></div>
                <div class="hint">Controls average and circle center.</div>
                <div class="slider"><input id="sx" type="range" min="-200" max="200" step="1" value="80" /></div>
              </div>
              <div class="valueBox"><span id="sxV">80</span></div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">σy <small>normal stress</small></div>
                <div class="hint">Affects center and differential term.</div>
                <div class="slider"><input id="sy" type="range" min="-200" max="200" step="1" value="-20" /></div>
              </div>
              <div class="valueBox"><span id="syV">-20</span></div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">τxy <small>shear stress</small></div>
                <div class="hint">Rotates the state around the circle.</div>
                <div class="slider"><input id="txy" type="range" min="-200" max="200" step="1" value="40" /></div>
              </div>
              <div class="valueBox"><span id="txyV">40</span></div>
            </div>

            <div style="height:8px"></div>

            <div class="row">
              <div class="meta">
                <div class="name">θ <small>plane angle</small></div>
                <div class="hint">Moves the point (σx′, τx′y′) along the Mohr circle.</div>
                <div class="slider"><input id="theta" type="range" min="0" max="180" step="0.1" value="25" /></div>
              </div>
              <div class="valueBox"><span id="thetaV">25.0</span>°</div>
            </div>

            <div class="twoCols">
              <div class="row" style="grid-template-columns:1fr;">
                <div class="meta">
                  <div class="name">θ min <small>range</small></div>
                  <div class="slider"><input id="thMin" type="range" min="-360" max="360" step="1" value="0" /></div>
                </div>
                <div class="valueBox"><span id="thMinV">0</span>°</div>
              </div>
              <div class="row" style="grid-template-columns:1fr;">
                <div class="meta">
                  <div class="name">θ max <small>range</small></div>
                  <div class="slider"><input id="thMax" type="range" min="-360" max="360" step="1" value="180" /></div>
                </div>
                <div class="valueBox"><span id="thMaxV">180</span>°</div>
              </div>
            </div>

            <div class="btnRow">
              <button id="playBtn">Play</button>
              <button id="pauseBtn">Pause</button>
              <button id="resetBtn">Reset</button>
              <button id="autoscaleBtn">Autoscale</button>
            </div>

            <div class="foot">
              Notes: σ-axis is horizontal, τ-axis is vertical. Circle equation:
              (σ − C)² + τ² = R², where C=(σx+σy)/2 and R = √(((σx−σy)/2)² + τxy²).
            </div>
          </div>
        </div>
      </section>

      <section class="charts">
        <div class="card">
          <div class="panelHead">
            <div class="k">Stress vs θ</div>
            <div class="legend">
              <span class="swatch"><span class="dot a"></span> σx′(θ)</span>
              <span class="swatch"><span class="dot b"></span> τx′y′(θ)</span>
              <span class="swatch"><span class="dot c"></span> cursor θ</span>
            </div>
          </div>
          <div class="panelBody">
            <div class="canvasWrap" id="stressWrap">
              <canvas id="stressCanvas"></canvas>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="panelHead">
            <div class="k">Mohr Circle</div>
            <div class="v" id="stateLine">σx′ = —, τx′y′ = —</div>
          </div>
          <div class="panelBody">
            <div class="canvasWrap small" id="mohrWrap">
              <canvas id="mohrCanvas"></canvas>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

<script>
(() => {

  const el = (id) => document.getElementById(id);

  const sx = el("sx"), sy = el("sy"), txy = el("txy");
  const theta = el("theta");
  const thMin = el("thMin"), thMax = el("thMax");
  const units = el("units");

  const sxV = el("sxV"), syV = el("syV"), txyV = el("txyV");
  const thetaV = el("thetaV"), thMinV = el("thMinV"), thMaxV = el("thMaxV");

  const derivedLine = el("derivedLine");
  const stateLine = el("stateLine");

  const playBtn = el("playBtn"), pauseBtn = el("pauseBtn"), resetBtn = el("resetBtn"), autoscaleBtn = el("autoscaleBtn");

  const stressCanvas = el("stressCanvas");
  const mohrCanvas = el("mohrCanvas");
  const stressWrap = el("stressWrap");
  const mohrWrap = el("mohrWrap");

  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rad = (deg) => deg * Math.PI / 180;

  function fmt(n){
    if(!isFinite(n)) return "—";
    const abs = Math.abs(n);
    if(abs >= 1000) return n.toFixed(0);
    if(abs >= 100) return n.toFixed(1);
    if(abs >= 10) return n.toFixed(2);
    return n.toFixed(3);
  }

  const C = {
    grid: "rgba(48,72,96,0.16)",
    axis: "rgba(31,44,60,0.3)",
    text: "rgba(31,44,60,0.96)",
    muted: "rgba(78,96,114,0.92)",
    blue: "rgba(37,95,133,0.95)",
    mint: "rgba(191,109,42,0.95)",
    amber: "rgba(122,75,153,0.95)",
    glowBlue: "rgba(37,95,133,0.16)",
    glowMint: "rgba(191,109,42,0.16)",
  };

  function fitEqualAspect(xMin, xMax, yMin, yMax, plotW, plotH){
    const cx = (xMin + xMax) / 2;
    const cy = (yMin + yMax) / 2;
    const xSpan = Math.max(1e-6, xMax - xMin);
    const ySpan = Math.max(1e-6, yMax - yMin);
    const upp = Math.max(xSpan / Math.max(1, plotW), ySpan / Math.max(1, plotH));
    const nx = upp * plotW;
    const ny = upp * plotH;
    return {
      xMin: cx - nx / 2,
      xMax: cx + nx / 2,
      yMin: cy - ny / 2,
      yMax: cy + ny / 2
    };
  }

  const state = {

    sxT: parseFloat(sx.value),
    syT: parseFloat(sy.value),
    txyT: parseFloat(txy.value),
    thetaT: parseFloat(theta.value),
    thMinT: parseFloat(thMin.value),
    thMaxT: parseFloat(thMax.value),
    unit: units.value,

    sx: parseFloat(sx.value),
    sy: parseFloat(sy.value),
    txy: parseFloat(txy.value),
    theta: parseFloat(theta.value),

    stressYPad: 1.18,
    stressYMin: -250,
    stressYMax: 250,
    mohrPad: 1.35,
    mohrXMin: -250,
    mohrXMax: 250,
    mohrYMin: -250,
    mohrYMax: 250,

    playing: false,
    lastTime: 0,
  };

  function sigmaPrime(sx, sy, txy, thetaDeg){
    const th2 = rad(2 * thetaDeg);
    return (sx + sy) / 2 + (sx - sy) / 2 * Math.cos(th2) + txy * Math.sin(th2);
  }

  function tauPrime(sx, sy, txy, thetaDeg){
    const th2 = rad(2 * thetaDeg);
    return - (sx - sy) / 2 * Math.sin(th2) + txy * Math.cos(th2);
  }

  function circleCenter(sx, sy){ return (sx + sy) / 2; }
  function circleRadius(sx, sy, txy){
    const a = (sx - sy) / 2;
    return Math.sqrt(a*a + txy*txy);
  }

  function resizeCanvas(canvas, wrap){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = wrap.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";
      const ctx = canvas.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    return canvas.getContext("2d");
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawGrid(ctx, w, h, padding, xMin, xMax, yMin, yMax, xLabel, yLabel){

    const left = padding.left, right = w - padding.right;
    const top = padding.top, bottom = h - padding.bottom;

    const g = ctx.createRadialGradient(left + (right-left)*0.25, top, 30, left + (right-left)*0.25, top, Math.max(w,h));
    g.addColorStop(0, "rgba(37,95,133,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const xToPx = (x) => left + (x - xMin) / (xMax - xMin) * (right - left);
    const yToPx = (y) => bottom - (y - yMin) / (yMax - yMin) * (bottom - top);

    ctx.lineWidth = 1;
    ctx.strokeStyle = C.grid;

    const nx = 6, ny = 5;
    for(let i=0;i<=nx;i++){
      const x = lerp(xMin, xMax, i/nx);
      const px = xToPx(x);
      ctx.beginPath();
      ctx.moveTo(px, top);
      ctx.lineTo(px, bottom);
      ctx.stroke();
    }
    for(let j=0;j<=ny;j++){
      const y = lerp(yMin, yMax, j/ny);
      const py = yToPx(y);
      ctx.beginPath();
      ctx.moveTo(left, py);
      ctx.lineTo(right, py);
      ctx.stroke();
    }

    ctx.strokeStyle = C.axis;
    if(xMin < 0 && xMax > 0){
      const px0 = xToPx(0);
      ctx.beginPath(); ctx.moveTo(px0, top); ctx.lineTo(px0, bottom); ctx.stroke();
    }
    if(yMin < 0 && yMax > 0){
      const py0 = yToPx(0);
      ctx.beginPath(); ctx.moveTo(left, py0); ctx.lineTo(right, py0); ctx.stroke();
    }

    ctx.fillStyle = C.muted;
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textBaseline = "top";
    ctx.fillText(xLabel, left, bottom + 10);
    ctx.save();
    ctx.translate(10, top);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.fillStyle = "rgba(78,96,114,0.82)";
    ctx.font = "11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    const pyTop = yToPx(yMax), pyBot = yToPx(yMin);
    ctx.fillText(fmt(yMax), left + 6, pyTop + 12);
    ctx.fillText(fmt(yMin), left + 6, pyBot - 12);

    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    const pxL = xToPx(xMin), pxR = xToPx(xMax);
    ctx.fillText(fmt(xMin), pxL + 26, bottom - 6);
    ctx.fillText(fmt(xMax), pxR - 26, bottom - 6);

    return {xToPx, yToPx, left, right, top, bottom};
  }

  function strokeGlow(ctx, color, glowColor, width){
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = 14;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }

  function dotGlow(ctx, x, y, color, glow){

    ctx.beginPath();
    ctx.fillStyle = glow;
    ctx.arc(x,y,10,0,Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x,y,4.2,0,Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.strokeStyle = "rgba(255,255,255,0.28)";
    ctx.lineWidth = 1;
    ctx.arc(x,y,6.4,0,Math.PI*2);
    ctx.stroke();
  }

  function drawStressPlot(ctx, w, h){
    const pad = {left: 50, right: 16, top: 18, bottom: 34};

    const th0 = state.thMinT, th1 = state.thMaxT;
    const N = 520;
    const xs = new Array(N);
    const sig = new Array(N);
    const tau = new Array(N);

    let sMin = Infinity, sMax = -Infinity;
    for(let i=0;i<N;i++){
      const th = lerp(th0, th1, i/(N-1));
      xs[i] = th;
      const sp = sigmaPrime(state.sx, state.sy, state.txy, th);
      const tp = tauPrime(state.sx, state.sy, state.txy, th);
      sig[i] = sp;
      tau[i] = tp;
      sMin = Math.min(sMin, sp, tp);
      sMax = Math.max(sMax, sp, tp);
    }

    const padFactor = state.stressYPad;
    const c = (sMin + sMax) / 2;
    const r = (sMax - sMin) / 2 || 1;
    const wantMin = c - r * padFactor;
    const wantMax = c + r * padFactor;

    state.stressYMin = lerp(state.stressYMin, wantMin, 0.12);
    state.stressYMax = lerp(state.stressYMax, wantMax, 0.12);

    const xMin = th0, xMax = th1;
    const yMin = state.stressYMin, yMax = state.stressYMax;

    const g = drawGrid(ctx, w, h, pad, xMin, xMax, yMin, yMax, "θ (deg)", `stress (${state.unit})`);

    const xToPx = g.xToPx, yToPx = g.yToPx;

    ctx.save();
    strokeGlow(ctx, C.blue, C.glowBlue, 2);
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = xToPx(xs[i]);
      const y = yToPx(sig[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    ctx.save();
    strokeGlow(ctx, C.mint, C.glowMint, 2);
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x = xToPx(xs[i]);
      const y = yToPx(tau[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    const th = state.theta;
    const sp = sigmaPrime(state.sx, state.sy, state.txy, th);
    const tp = tauPrime(state.sx, state.sy, state.txy, th);

    ctx.save();
    const px = xToPx(th);
    ctx.strokeStyle = "rgba(122,75,153,0.42)";
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(px, g.top);
    ctx.lineTo(px, g.bottom);
    ctx.stroke();
    ctx.restore();

    dotGlow(ctx, px, yToPx(sp), C.blue, "rgba(37,95,133,0.2)");
    dotGlow(ctx, px, yToPx(tp), C.mint, "rgba(191,109,42,0.2)");

    ctx.fillStyle = C.text;
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillText(`σx′ = ${fmt(sp)} ${state.unit}`, w - 18, 16);
    ctx.fillText(`τx′y′ = ${fmt(tp)} ${state.unit}`, w - 18, 34);
  }

  function drawMohr(ctx, w, h){
    const pad = {left: 50, right: 18, top: 18, bottom: 34};

    const Cc = circleCenter(state.sx, state.sy);
    const R = circleRadius(state.sx, state.sy, state.txy);

    const wantXMin = Cc - R * state.mohrPad;
    const wantXMax = Cc + R * state.mohrPad;
    const wantYMin = -R * state.mohrPad;
    const wantYMax =  R * state.mohrPad;

    state.mohrXMin = lerp(state.mohrXMin, wantXMin, 0.12);
    state.mohrXMax = lerp(state.mohrXMax, wantXMax, 0.12);
    state.mohrYMin = lerp(state.mohrYMin, wantYMin, 0.12);
    state.mohrYMax = lerp(state.mohrYMax, wantYMax, 0.12);

    const plotW = w - pad.left - pad.right;
    const plotH = h - pad.top - pad.bottom;
    const fitted = fitEqualAspect(state.mohrXMin, state.mohrXMax, state.mohrYMin, state.mohrYMax, plotW, plotH);
    const g = drawGrid(ctx, w, h, pad, fitted.xMin, fitted.xMax, fitted.yMin, fitted.yMax, `σ (${state.unit})`, `τ (${state.unit})`);
    const xToPx = g.xToPx, yToPx = g.yToPx;

    const cx = xToPx(Cc);
    const cy = yToPx(0);

    ctx.save();
    ctx.strokeStyle = "rgba(37,95,133,0.66)";
    ctx.lineWidth = 2;
    ctx.shadowColor = "rgba(37,95,133,0.12)";
    ctx.shadowBlur = 10;
    ctx.beginPath();
    const N = 220;
    for(let i=0;i<=N;i++){
      const a = (i / N) * Math.PI * 2;
      const sxp = Cc + R * Math.cos(a);
      const typ = R * Math.sin(a);
      const xp = xToPx(sxp);
      const yp = yToPx(typ);
      if(i === 0) ctx.moveTo(xp, yp);
      else ctx.lineTo(xp, yp);
    }
    ctx.stroke();
    ctx.restore();

    dotGlow(ctx, cx, cy, "rgba(31,44,60,0.85)", "rgba(31,44,60,0.08)");

    const th = state.theta;
    const sp = sigmaPrime(state.sx, state.sy, state.txy, th);
    const tp = tauPrime(state.sx, state.sy, state.txy, th);

    const px = xToPx(sp);
    const py = yToPx(tp);

    ctx.save();
    ctx.strokeStyle = "rgba(122,75,153,0.36)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(px, py);
    ctx.stroke();
    ctx.restore();

    dotGlow(ctx, px, py, C.amber, "rgba(122,75,153,0.22)");

    const s1 = Cc + R, s2 = Cc - R;
    dotGlow(ctx, xToPx(s1), yToPx(0), "rgba(191,109,42,0.9)", "rgba(191,109,42,0.18)");
    dotGlow(ctx, xToPx(s2), yToPx(0), "rgba(191,109,42,0.9)", "rgba(191,109,42,0.18)");

    ctx.fillStyle = C.text;
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(`C = ${fmt(Cc)} ${state.unit}`, 58, 16);
    ctx.fillText(`R = ${fmt(R)} ${state.unit}`, 58, 34);

    stateLine.textContent = `σx′ = ${fmt(sp)} ${state.unit},  τx′y′ = ${fmt(tp)} ${state.unit}`;
  }

  function smoothStep(){

    const k = 0.14;
    state.sx  = lerp(state.sx,  state.sxT,  k);
    state.sy  = lerp(state.sy,  state.syT,  k);
    state.txy = lerp(state.txy, state.txyT, k);

    state.theta = state.thetaT;
  }

  function render(now){
    if(!state.lastTime) state.lastTime = now;
    const dt = Math.min(0.05, (now - state.lastTime) / 1000);
    state.lastTime = now;

    if(state.playing){

      const speed = 28;
      const a = state.thMinT, b = state.thMaxT;
      const span = Math.max(1e-6, b - a);
      let th = state.thetaT + speed * dt;
      th = a + ((((th - a) % span) + span) % span);
      state.thetaT = clamp(th, a, b);
      theta.value = state.thetaT.toFixed(2);
      thetaV.textContent = state.thetaT.toFixed(1);
    }

    smoothStep();

    const Cc = circleCenter(state.sx, state.sy);
    const R = circleRadius(state.sx, state.sy, state.txy);
    derivedLine.textContent = `Center C = ${fmt(Cc)} ${state.unit}, Radius R = ${fmt(R)} ${state.unit}`;

    const ctx1 = resizeCanvas(stressCanvas, stressWrap);
    const rect1 = stressWrap.getBoundingClientRect();
    clear(ctx1, rect1.width, rect1.height);
    drawStressPlot(ctx1, rect1.width, rect1.height);

    const ctx2 = resizeCanvas(mohrCanvas, mohrWrap);
    const rect2 = mohrWrap.getBoundingClientRect();
    clear(ctx2, rect2.width, rect2.height);
    drawMohr(ctx2, rect2.width, rect2.height);

    requestAnimationFrame(render);
  }

  function bindSlider(sl, out, key){
    const onInput = () => {
      const v = parseFloat(sl.value);
      out.textContent = (key === "theta" ? v.toFixed(1) : v.toFixed(0));
      state[key + "T"] = v;
    };
    sl.addEventListener("input", onInput);
    onInput();
  }

  bindSlider(sx, sxV, "sx");
  bindSlider(sy, syV, "sy");
  bindSlider(txy, txyV, "txy");

  theta.addEventListener("input", () => {
    const v = parseFloat(theta.value);
    state.thetaT = v;
    thetaV.textContent = v.toFixed(1);
  });

  function syncThetaRange(){
    let a = parseFloat(thMin.value);
    let b = parseFloat(thMax.value);
    if(b < a){ const t=a; a=b; b=t; }

    if(b - a < 5) b = a + 5;

    state.thMinT = a;
    state.thMaxT = b;

    thMinV.textContent = a.toFixed(0);
    thMaxV.textContent = b.toFixed(0);

    theta.min = a;
    theta.max = b;

    state.thetaT = clamp(state.thetaT, a, b);
    theta.value = state.thetaT.toFixed(2);
    thetaV.textContent = state.thetaT.toFixed(1);
  }

  thMin.addEventListener("input", syncThetaRange);
  thMax.addEventListener("input", syncThetaRange);
  syncThetaRange();

  units.addEventListener("change", () => {
    state.unit = units.value;
  });

  playBtn.addEventListener("click", () => { state.playing = true; });
  pauseBtn.addEventListener("click", () => { state.playing = false; });

  resetBtn.addEventListener("click", () => {
    state.playing = false;
    sx.value = 80; sy.value = -20; txy.value = 40;
    theta.value = 25;
    thMin.value = 0; thMax.value = 180;

    state.sxT = 80; state.syT = -20; state.txyT = 40;
    state.thetaT = 25;
    state.thMinT = 0; state.thMaxT = 180;

    sxV.textContent = "80";
    syV.textContent = "-20";
    txyV.textContent = "40";
    thetaV.textContent = "25.0";
    syncThetaRange();
  });

  autoscaleBtn.addEventListener("click", () => {

    state.stressYPad = 1.20;
    state.mohrPad = 1.35;

    const Cc = circleCenter(state.sx, state.sy);
    const R = circleRadius(state.sx, state.sy, state.txy);

    state.mohrXMin = Cc - R * 1.35;
    state.mohrXMax = Cc + R * 1.35;
    state.mohrYMin = -R * 1.35;
    state.mohrYMax =  R * 1.35;

    state.stressYMin = (Cc - R) * 1.25;
    state.stressYMax = (Cc + R) * 1.25;
  });

  window.addEventListener("resize", () => {

    state.lastTime = 0;
  });

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
